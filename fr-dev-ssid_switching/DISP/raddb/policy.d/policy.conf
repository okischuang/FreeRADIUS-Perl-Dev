# -*- text -*-
##
## policy.conf	-- FreeRADIUS server configuration file.
##
##	http://www.freeradius.org/
##	$Id$
##

#
#  Policies are virtual modules, similar to those defined in the
#  "instantate" section of radiusd.conf.
#
#  Defining a policy here means that it can be referenced in multiple
#  places as a *name*, rather than as a series of conditions to match,
#  and actions to take.
#
#  Policies are something like subroutines in a normal language, but
#  they cannot be called recursively.  They MUST be defined in order.
#  If policy A calls policy B, then B MUST be defined before A.
#


#       WISPr-Location-ID, WISPr-Location-Name generating
#
set_wispr_location.authorize {
        if(!"%{WISPr-Location-ID}"){
                update request{
                        WISPr-Location-ID := "isocc=tw,cc=886,ac=2,network=HiNet"
                }
        }
        if(!"%{WISPr-Location-Name}"){
                if("%{control:Tmp-Class-Str}" =~ /Venue_ID=([A-Za-z0-9_]+)\\sHotspot_ID=([A-Za-z0-9_]+)/) {
                        update request{
                                WISPr-Location-Name := "HiNet, %{1}_%{2}"
                        }
                }
                else{
                        update request{
                                WISPr-Location-Name := "HiNet,P999999_PH999999"
                        }
                }
        }
}
set_wispr_location.post.auth {
        if(!"%{reply:WISPr-Location-ID}"){
                update reply{
                        WISPr-Location-ID := "isocc=tw,cc=886,ac=2,network=HiNet"
                }
        }
        if(!"%{reply:WISPr-Location-Name}"){
                if("%{control:Tmp-Class-Str}" =~ /Venue_ID=([A-Za-z0-9_]+)\\sHotspot_ID=([A-Za-z0-9_]+)/) {
                        update reply{
                                WISPr-Location-Name := "HiNet, %{1}_%{2}"
                        }
                }
                else{
                        update reply{
                                WISPr-Location-Name := "HiNet,P999999_PH999999"
                        }
                }
        }
}
	
	#
	#   
	#
	set_stripped_uname {
		if(User-Name =~ /(.+)\/(.+)/) {
         		update request{
                		Stripped-User-Name := "%{2}"
                	}
        	}
        	elsif(User-Name =~ /(.+)@(.+)/) {
			if("%{2}" == "hotspot") {
		              	update request{
                		      	Stripped-User-Name := "%{1}"
					Realm := "%{2}"
				}
                	}
			else {
				update request{
                                        Stripped-User-Name := "%{1}"
                                }
			}
        	}
        	else {
                	update request{
                        	Stripped-User-Name := "none"
                	}
        	}
	}	

	#
	#   Settle down all eap-sim required AVP in the return of Access-Accept to gateway.
	#   For local EAP-SIM user
	#
	eapsim_local_set_qos {
		update reply {
			Alc-Subscriber-QoS-Override := "i:p:1:pir=5120,mbs=2048000"
			Alc-Subscriber-QoS-Override += "e:q:1:pir=20480"
			Alc-Relative-Session-Timeout:=14400
			Idle-Timeout:=1800
                        Alc-SLA-Prof-Str := "CHT_SLA"
                        Alc-Subsc-Prof-Str := "EAP_SUB"
			#Alc-Subsc-Id-Str := "%{Calling-Station-Id}|%l"
                        Framed-Pool := "CHT_POOL"
               	} 
	}	

	#   
	#   Policy of CHT Wi-Fi EAP-SIM to save value of *Chargeable-User-Identity* 
	#   from mobile AAA's reply to *Tmp-User-Identity*.
	#
	#   Due to lack of CUI support by 4IPnet gateway, we do a workaround by unlang that saving CUI value at post-auth stage
	#   then making new Chargeable-User-Identity attribute in another section we need, like "accounting".
	#                   
	save_user_identity {
		if("%{reply:Chargeable-User-Identity}"){
			update reply {
				Class += "CUI=%{reply:Chargeable-User-Identity}"
			}
		}
	}
	#
	#   Policy of generating attribute Chargeable-User-Identity from one of Class AVP 
	#   saved with the value of attribute Chargeable-User-Identity.
	#
	gen_user_identity {
		if("%{request:Class[*]}" =~ /.*CUI=([0-9]+).*/) {
			update request {
                                Chargeable-User-Identity := "%{1}"
                        }
		}
	}

	#
	#   Get local hotspot information by oracle package function and put it into attribute *Tmp-Class-Str* in 'dictionary.freeradius.internal'
	#                
	get_hotspot_info {
		if("%{sql_oda:select wifi_pm.get_hotspot_info('%{NAS-IP-address}','%{NAS-Port}') from dual}" =~ /(.+)\\|(.+)/) {
			update control{
                                Tmp-Class-Str = "%{1}"
                        }
		}
		else {
			update control{
                                Tmp-Class-Str = "Venue_ID=P999999 Hotspot_ID=PH999999"
                        }
		}
	}
	get_hotspot_info2 {
		if("%{sql_proxy_check2:select wifi_pm.get_hotspot_info('%{NAS-IP-address}','%{NAS-Port}') from dual}" =~ /(.+)\\|(.+)/) {
			update control{
                                Tmp-Class-Str = "%{1}"
                        }
		}
		else {
			update control{
                                Tmp-Class-Str = "Venue_ID=P999999 Hotspot_ID=PH999999"
                        }
		}
	}
	
	# update Gateway-Type into freeradius.internal attribute *Gateway-Type*	
	update_gw_type {
		#if("%{NAS-IP-Address}" == 168.95.179.1 || "%{NAS-IP-Address}" == 168.95.179.2) {
		if("%{client:Platform}" == "2nd") {
			update control {
				Gateway-Type := "ALU"
			}
		}
	}
	# get proxy check string from executing xlat calling stored procedure
	proxy_auth_check {
		update control {
			Proxy-Check-Str := "%{sql_oda:select wifi_pm.proxy_auth_check_cht('%{Stripped-User-Name}','%{User-Password}','%{FreeRADIUS-WiFi-Realm}','%{Calling-Station-id}','%{NAS-IP-address}','%{NAS-Port}') from dual}"
		}
	}

	proxy_check {
		#
		# 	if sql returns /(.+)\\|(.+)/ format, it means that proxy-auth-chech is success. 
		#	The string it returned includes Hotspot info for need of 'ProxyCL' Class attribute and HTTP URL which WISPr-Redirection-URL needs.
		#
		if("%{sql_proxy_check2:select wifi_pm.proxy_auth_check('%{Stripped-User-Name}','%{User-Password}','%{FreeRADIUS-WiFi-Realm}','%{Calling-Station-id}','%{NAS-IP-address}','%{NAS-Port}') from dual}" =~ /(.+)\\|(.+)/){
	                update control{
        	                Tmp-Class-Str = "%{1}"
				Tmp-URL-Str = "%{2}"
                	}
			if("%{FreeRADIUS-WiFi-Realm}" == "hotspot") {
				update control {
					Auth-Type := Accept
				}
			}
        	}
		#
		#	if sql returns '55', which means this user account has logged in before and being used now.
		#
        	elsif("%{sql_proxy_check2:select wifi_pm.proxy_auth_check('%{Stripped-User-Name}','%{User-Password}','%{FreeRADIUS-WiFi-Realm}','%{Calling-Station-id}','%{NAS-IP-address}','%{NAS-Port}') from dual}"=="55"){
			update reply {
				Reply-Message := "55"
			}	
                	reject
        	}
		elsif("%{sql_proxy_check2:select wifi_pm.proxy_auth_check('%{Stripped-User-Name}','%{User-Password}','%{FreeRADIUS-WiFi-Realm}','%{Calling-Station-id}','%{NAS-IP-address}','%{NAS-Port}') from dual}"=='63'){
			update reply {
				Reply-Message := "63"
			}
			reject
        	}
		elsif("%{sql_proxy_check2:select wifi_pm.proxy_auth_check('%{Stripped-User-Name}','%{User-Password}','%{FreeRADIUS-WiFi-Realm}','%{Calling-Station-id}','%{NAS-IP-address}','%{NAS-Port}') from dual}"=='22'){
                        update reply { 
                                Reply-Message := "22" 
                        }       
                        reject  
                }
		elsif("%{sql_proxy_check2:select wifi_pm.proxy_auth_check('%{Stripped-User-Name}','%{User-Password}','%{FreeRADIUS-WiFi-Realm}','%{Calling-Station-id}','%{NAS-IP-address}','%{NAS-Port}') from dual}" =~ /hotspot\\s[A-Za-z0-9_]+\\snot\\sfound/){
			update reply {
                                Reply-Message := "60" 
                        }
                        reject
		}
		#else{
                #	sql_proxy_check2
		#	noop
        	#}
	}
	
	proxy_check2 {
		#
		# 	if sql returns /(.+)\\|(.+)/ format, it means that proxy-auth-chech is success. 
		#	The string it returned includes Hotspot info for need of 'ProxyCL' Class attribute and HTTP URL which WISPr-Redirection-URL needs.
		#
		
		if("%{sql_oda:select wifi_pm.proxy_auth_check('%{Stripped-User-Name}','%{User-Password}','%{FreeRADIUS-WiFi-Realm}','%{Calling-Station-id}','%{NAS-IP-address}','%{NAS-Port}') from dual}" =~ /(.+)\\|(.+)/){
	                update control{
        	                Tmp-Class-Str = "%{1}"
				Tmp-URL-Str = "%{2}"
                	}
			if("%{FreeRADIUS-WiFi-Realm}" == "hotspot") {
				############## TEMP ##############
				# Only for ALU 7750 GW
				#if("%{control:Gateway-Type}" == "ALU") {
				if("%{client:Platform}" == "2nd") {
					update control {
						Auth-Type := Accept
					}
				}
				############## TEMP ##############
			}
        	}
		#
		#	if sql returns '55', which means this user account has logged in before and being used now.
		#
        	elsif("%{sql_oda:select wifi_pm.proxy_auth_check('%{Stripped-User-Name}','%{User-Password}','%{FreeRADIUS-WiFi-Realm}','%{Calling-Station-id}','%{NAS-IP-address}','%{NAS-Port}') from dual}"=="55"){
			update reply {
				Reply-Message := "55"
			}	
                	reject
        	}
		elsif("%{sql_oda:select wifi_pm.proxy_auth_check('%{Stripped-User-Name}','%{User-Password}','%{FreeRADIUS-WiFi-Realm}','%{Calling-Station-id}','%{NAS-IP-address}','%{NAS-Port}') from dual}"=='63'){
			####### TEMP ########
			#  While now our Hotspot database has not yet ready, so just Reject request from ALU-GW.......2014/04/11
			####### TEMP ########
			if("%{client:Platform}" == "2nd") {
				update reply {
					Reply-Message := "63"
				}
				reject
			}
			else{
				noop
			}
        	}
		elsif("%{sql_oda:select wifi_pm.proxy_auth_check('%{Stripped-User-Name}','%{User-Password}','%{FreeRADIUS-WiFi-Realm}','%{Calling-Station-id}','%{NAS-IP-address}','%{NAS-Port}') from dual}"=='22'){
                        update reply { 
                                Reply-Message := "22" 
                        }       
                        reject  
                }
		elsif("%{sql_oda:select wifi_pm.proxy_auth_check('%{Stripped-User-Name}','%{User-Password}','%{FreeRADIUS-WiFi-Realm}','%{Calling-Station-id}','%{NAS-IP-address}','%{NAS-Port}') from dual}" =~ /hotspot\\s[A-Za-z0-9_]+\\snot\\sfound/){
			update reply {
                                Reply-Message := "60" 
                        }
                        reject
		}
		#else{
                #	sql_oda
		#	noop
        	#}
	}

	gen_Class{
		if(!"%{control:Tmp-Class-Str}") {
                        update control{
                                Tmp-Class-Str = "Venue_ID=P999999 Hotspot_ID=PH999999"
                        }
			update reply {
				Class += "ProxyCL:%{control:Tmp-Class-Str}"
			}
		}
		else {
			update reply {
				Class += "ProxyCL:%{control:Tmp-Class-Str}"
			}
		}
	}	
	gen_Class_acct{
		if(!"%{control:Tmp-Class-Str}") {
                        update control{
                                Tmp-Class-Str = "Venue_ID=P999999 Hotspot_ID=PH999999"
                        }
			update request {
                                Class += "ProxyCL:%{control:Tmp-Class-Str}"
                        }
                }
                else {
                        update request {
                                Class += "ProxyCL:%{control:Tmp-Class-Str}"
                        }
                }
        }
	gen_URL {
	#	if("%{control:Tmp-Class-Str}" =~ /Venue_ID=(.+)\sHotspot_ID=(.+)/) {
					
		if("%{reply:WISPr-Redirection-URL}") {  
					
			if("%{control:Tmp-URL-Str}" && "%{reply:WISPr-Redirection-URL}" =~ /(.+)?service=(.+)\&/) {
				update reply {
                                       	WISPr-Redirection-URL:="%{control:Tmp-URL-Str}?service=%{2}&settime=&duration=0&apno="
				}
				if("%{control:Tmp-Class-Str}" =~ /Venue_ID=([A-Za-z0-9_]+)\\sHotspot_ID=([A-Za-z0-9_]+)/) {
					update reply {
						WISPr-Redirection-URL := "%{reply:WISPr-Redirection-URL}%{2}"
					}
				}
			}
				
        	}
        	else {
			
			#   emomeCL case
			if("%{reply:Class[*]}" =~ /(.+)RC\=([A-Za-Z0-9]+)/) {
				update reply {
                                        WISPr-Redirection-URL:="http://www.hinet.net/wifi/?service=%{2}&settime=&duration=0&apno="
                                }
				if("%{control:Tmp-Class-Str}" =~ /Venue_ID=([A-Za-z0-9_]+)\\sHotspot_ID=([A-Za-z0-9_]+)/){
                                	update reply {
                                        	WISPr-Redirection-URL:="%{reply:WISPr-Redirection-URL}%{2}"
                                	}
				}
                        }
			elsif("%{control:Tmp-URL-Str}" && "%{control:Tmp-Class-Str}" =~ /^[A-Za-z0-9_]+\=(.+)\\s[A-Za-z0-9_]+\=(.+)/) {
                		update reply {
                        		WISPr-Redirection-URL:="http://www.hinet.net/wifi/?settime=&duration=0&apno=%{2}"
                		}
			}
			else{
				update reply {
                                        WISPr-Redirection-URL:="http://www.hinet.net/wifi/?service=0&settime=&duration=0&apno=PH000000"
                                }
                	}
       		}
	}
	
	gen_gigawords {
		if(!"%{Acct-Input-Gigawords}") {
                	update request {
                                Acct-Input-Gigawords := 0
                        }
                }
                if(!"%{Acct-Output-Gigawords}") {
                        update request {
                                Acct-Output-Gigawords := 0
                        }
                }
	}
	
	#
	#	Remove CUI Class AVP
	#
	remove_cui_class {
		if("%{proxy-request:Class[*]}" =~ /(CUI=[a-zA-Z0-9_]+\n)/) {
			update proxy-request {
				Class -= "%{1}"
			}
		}
	}
				
	#
	#	Accounting Packets Processing
	#
	process_acct {
		switch "%{Acct-Status-Type}" {
			case Start {
				if("%{Alc-Subsc-ID-Str}" =~ /(.+)(:o)/) {
					ok
				}	
			}
			case Stop {
				
			}
		}
	}
	
	#
	#	Override Reply-Message returned from International WISPr if Access-Reject was returned.
	#
	override_replyMsg_on_reject {
		update reply {
			Reply-Message:="41"
		}
	}

	#
	#	Access-Reject Reply Message Handle
	#
	reject.reply_message {
		if("%{reply:Reply-Message}" == "Request Denied" && "%{FreeRADIUS-WiFi-Realm}" == "emome.net"){	
			update reply {
                        	Reply-Message:="22"
                	}
		}
	}

	#
	#	Forbid all EAP types.
	#
	forbid_eap {
		if (EAP-Message) {
			reject
		}
	}

	#
	#	Forbid all non-EAP types outside of an EAP tunnel.
	#
	permit_only_eap {
		if (!EAP-Message) {
			#  We MAY be inside of a TTLS tunnel.
			#  PEAP and EAP-FAST require EAP inside of
			#  the tunnel, so this check is OK.
			#  If so, then there MUST be an outer EAP message.
			if (!"%{outer.request:EAP-Message}") {
				reject
			}
		}
	}
	
	#
	#
	#
	change_pccw_eapsim_port	{
		if(FreeRADIUS-WiFi-Realm=="wlan.mnc019.mcc454.3gppnetwork.org" || FreeRADIUS-WiFi-Realm=="wlan.mnc016.mcc454.3gppnetwork.org") {
			if(Packet-Type == "Access-Request") {
				update control {
					Packet-Dst-Port := 9415
				}
			}
			elsif(Packet-Type == "Accounting-Request") {
				update control {
                                        Packet-Dst-Port := 9416
                                }
			}
			else{
			}
		}
	}
	#
	#	Forbid all attempts to login via realms.
	#
	deny_realms {
		if (User-Name =~ /@|\\/) {
			reject
		}
	}

	#
	#	If you want the server to pretend that it is dead,
	#	then use the "do_not_respond" policy.
	#
	do_not_respond {
		update control {
			Response-Packet-Type := Do-Not-Respond
		}

		handled
	}

	#
	#  Filter Called-Station-Id out from EAP-Sim access request.
	#
	filter_called_station_id {
		if(Called-Station-Id) {
			update request {
				Called-Station-Id !* ANY
			}
		}
	}
	
	#
	#  Force some sanity on User-Name.  This helps to avoid issues
	#  issues where the back-end database is "forgiving" about
	#  what constitutes a user name.
	#
	filter_username {
		#
		#  reject mixed case
		#  e.g. "UseRNaMe"
		#
		if (User-Name != "%{tolower:%{User-Name}}") {
			reject
		}

		#
		#  reject all whitespace
		#  e.g. "user@ site.com", or "us er", or " user", or "user "
		#
		if (User-Name =~ / /) {
			update reply {
				Reply-Message += "Rejected: Username contains whitespace"
			}
			reject
		}

		#
		#  reject Multiple @'s
		#  e.g. "user@site.com@site.com"
		#
		if(User-Name =~ /@(.+)?@/i ) {
			update reply {
				Reply-Message += "Rejected: Multiple @ in username"
			}
			reject
		}

		#
		#  reject double dots
		#  e.g. "user@site..com"
		#
		if (User-Name =~ /\\.\\./ ) {
			update reply {
				Reply-Message += "Rejected: Username comtains ..s"
			}
			reject
		}

		#
		#  must have at least 1 string-dot-string after @
		#  e.g. "user@site.com"
		#
		if (User-Name !~ /@(.+)\\.(.+)$/)  {
			update reply {
				Reply-Message += "Rejected: Realm does not have at least one dot seperator"
			}
			reject
		}

		#
		#  Realm ends with a dot
		#  e.g. "user@site.com."
		#
                if (User-Name =~ /\\.$/)  {
                        update reply {
                                Reply-Message += "Rejected: Realm ends with a dot"
                        }
                        reject
                }

		#
                #  Realm begins with a dot
		#  e.g. "user@.site.com"
                #
                if (User-Name !~ /@\\./)  {
                        update reply {
                                Reply-Message+ = "Rejected: Realm begins with a dot"
                        }
                        reject
                }
	}

	#	
	#  The following policies are for the Chargeable-User-Identity
	#  (CUI) configuration.
	#

	#
	#  The client indicates it can do CUI by sending a CUI attribute	
	#  containing one zero byte
	#
	cui_authorize {
		update request {
			Chargeable-User-Identity:='\\000'
		}
	}

	#
	#  Add a CUI attribute based on the User-Name, and a secret key
	#  known only to this server.
	#
	cui_postauth {
		if (FreeRadius-Proxied-To == 127.0.0.1) {
			if (outer.request:Chargeable-User-Identity) {
				update outer.reply {
					Chargeable-User-Identity:="%{md5:%{config:cui_hash_key}%{User-Name}}"
				}
			}
		}
		else {
			if (Chargeable-User-Identity) {
				update reply {
					Chargeable-User-Identity="%{md5:%{config:cui_hash_key}%{User-Name}}"
				}
			}
		}
	}

	#
	#  If there is a CUI attribute in the reply, add it to the DB.
	#
	cui_updatedb {
		if (reply:Chargeable-User-Identity) {
			cui
		}
	}

	#
	#  If we had stored a CUI for the User, add it to the request.
	#
	cui_accounting {
		#
		#  If the CUI isn't in the packet, see if we can find it
		#  in the DB.
		#
		if (!Chargeable-User-Identity) {
			update request {
				Chargeable-User-Identity := "%{cui: SELECT cui FROM cui WHERE clientipaddress = '%{Client-IP-Address}' AND callingstationid = '%{Calling-Station-Id}' AND username = '%{User-Name}'}"
			}
		}

		#
		#  If it exists now, then write out when we last saw
		#  this CUI.
		#
		if (Chargeable-User-Identity && (Chargeable-User-Identity != "")) {
			cui
		}
	}

	#
	#  Normalize the MAC Addresses in the Calling/Called-Station-Id
	#
	mac-addr = ([0-9a-f]{2})[^0-9a-f]?([0-9a-f]{2})[^0-9a-f]?([0-9a-f]{2})[^0-9a-f]?([0-9a-f]{2})[^0-9a-f]?([0-9a-f]{2})[^0-9a-f]?([0-9a-f]{2})

	#  Add "rewrite.called_station_id" in the "authorize" and "preacct"
	#  sections.
	rewrite.called_station_id {
		if((Called-Station-Id) && "%{Called-Station-Id}" =~ /^%{config:policy.mac-addr}(:(.+))?$/i) {
			update request {
				Called-Station-Id := "%{tolower:%{1}-%{2}-%{3}-%{4}-%{5}-%{6}}"
			}

			# SSID component?
			if ("%{8}") {
				update request {
					Called-Station-Id := "%{Called-Station-Id}:%{8}"
				}
			}
			updated
		}
		else {
			noop
		}
	}

	#  Add "rewrite.calling_station_id" in the "authorize" and "preacct"
	#  sections.
	rewrite.calling_station_id {
		if((Calling-Station-Id) && "%{Calling-Station-Id}" =~ /^%{config:policy.mac-addr}$/i) {
			update request {
				Calling-Station-Id := "%{tolower:%{1}-%{2}-%{3}-%{4}-%{5}-%{6}}"
			}
			updated
		}
		else {
			noop
		}
	}

	#  Assign compatibility data to request for sqlippool
	dhcp_sqlippool.post-auth {


		#  Do some minor hacks to the request so that it looks
		#  like a RADIUS request to the SQL IP Pool module.
		update request {
			User-Name = "DHCP-%{DHCP-Client-Hardware-Address}"
			Calling-Station-Id = "%{DHCP-Client-Hardware-Address}"
			NAS-IP-Address = "%{%{DHCP-Gateway-IP-Address}:-127.0.0.1}"
			Acct-Status-Type = Start
		}

		#  Call the actual module
		#
		#  Uncomment this in order to really call it!
#		dhcp_sqlippool
		fail

		#  Convert Framed-IP-Address to DHCP, but only if we
		#  actually allocated an address.
		if (ok) {
			update reply {
				DHCP-Your-IP-Address = "%{reply:Framed-IP-Address}"
			}
		}
	}
