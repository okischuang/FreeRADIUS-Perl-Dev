######################################################################
#
#	As of 2.0.0, FreeRADIUS supports virtual hosts using the
#	"server" section, and configuration directives.
#
#	Virtual hosts should be put into the "sites-available"
#	directory.  Soft links should be created in the "sites-enabled"
#	directory to these files.  This is done in a normal installation.
#
#	If you are using 802.1X (EAP) authentication, please see also
#	the "inner-tunnel" virtual server.  You wll likely have to edit
#	that, too, for authentication to work.
#
#	$Id$
#
######################################################################
#
#	Read "man radiusd" before editing this file.  See the section
#	titled DEBUGGING.  It outlines a method where you can quickly
#	obtain the configuration you want, without running into
#	trouble.  See also "man unlang", which documents the format
#	of this file.
#
#	This configuration is designed to work in the widest possible
#	set of circumstances, with the widest possible number of
#	authentication methods.  This means that in general, you should
#	need to make very few changes to this file.
#
#	The best way to configure the server for your local system
#	is to CAREFULLY edit this file.  Most attempts to make large
#	edits to this file will BREAK THE SERVER.  Any edits should
#	be small, and tested by running the server with "radiusd -X".
#	Once the edits have been verified to work, save a copy of these
#	configuration files somewhere.  (e.g. as a "tar" file).  Then,
#	make more edits, and test, as above.
#
#	There are many "commented out" references to modules such
#	as ldap, sql, etc.  These references serve as place-holders.
#	If you need the functionality of that module, then configure
#	it in radiusd.conf, and un-comment the references to it in
#	this file.  In most cases, those small changes will result
#	in the server being able to connect to the DB, and to
#	authenticate users.
#
######################################################################

#
#	In 1.x, the "authorize", etc. sections were global in
#	radiusd.conf.  As of 2.0, they SHOULD be in a server section.
#
#	The server section with no virtual server name is the "default"
#	section.  It is used when no server name is specified.
#
#	We don't indent the rest of this file, because doing so
#	would make it harder to read.
#

#  Authorization. First preprocess (hints and huntgroups files),
#  then realms, and finally look in the "users" file.
#
#  Any changes made here should also be made to the "inner-tunnel"
#  virtual server.
#
#  The order of the realm modules will determine the order that
#  we try to find a matching realm.
#
#  Make *sure* that 'preprocess' comes before any realm if you 
#  need to setup hints for the remote radius server

##################################################################
#
#	Virtual Server for CHT Wi-Fi (Portal and EAP-SIM)
#
##################################################################

authorize {
	#bypass_nms
	#
	#  Security settings.  Take a User-Name, and do some simple
	#  checks on it, for spaces and other invalid characters.  If
	#  it looks like the user is trying to play games, reject it.
	#
	#  This should probably be enabled by default.
	#
	#  See policy.conf for the definition of the filter_username policy.
	#
#	filter_username
	
	# Adding "Client-Short-Name" to request list
	add_client_info
	# Adding "Gateway-Type" in client.conf into control list
	update_gw_type

	#  Formalize Calling-Station-Id 
	rewrite.calling_station_id
	
	#
	#  The preprocess module takes care of sanitizing some bizarre
	#  attributes in the request, and turning them into attributes
	#  which are more standard.
	#
	#  It takes care of processing the 'raddb/hints' and the
	#  'raddb/huntgroups' files.
#	preprocess

	#########################################################
	#	DO NOT Change the order of following module     #
	#########################################################
	#
	#  Read the 'users' file
	files
	#if(noop) {
		# Use perl to control realm proxy function
		perl_set_realm
		#project_underline
		#IPASS
		#suffix
	#}
	#########################################################
	#       DO NOT Change the order of following module     #
        #########################################################
	
	#
	#  BYPASS MODULE
	#
	#perl_bypass	

	
	#
	#  The chap module will set 'Auth-Type := CHAP' if we are
	#  handling a CHAP request and Auth-Type has not already been set
#	chap

	#
	#  If the users are logging in with an MS-CHAP-Challenge
	#  attribute for authentication, the mschap module will find
	#  the MS-CHAP-Challenge attribute, and add 'Auth-Type := MS-CHAP'
	#  to the request, which will cause the server to then use
	#  the mschap module for authentication.
#	mschap

	#
	#  If you have a Cisco SIP server authenticating against
	#  FreeRADIUS, uncomment the following line, and the 'digest'
	#  line in the 'authenticate' section.
#	digest

	#
	#  The WiMAX specification says that the Calling-Station-Id
	#  is 6 octets of the MAC.  This definition conflicts with
	#  RFC 3580, and all common RADIUS practices.  Un-commenting
	#  the "wimax" module here means that it will fix the
	#  Calling-Station-Id attribute to the normal format as
	#  specified in RFC 3580 Section 3.21
#	wimax

	#
	#  Check format of project prefix
	#
	#perl_check_project_prefix

	

	#
	#  Look for IPASS style 'realm/', and if not found, look for
	#  '@realm', and decide whether or not to proxy, based on
	#  that.
	#reject_ipass_cht_roamin

		
	############### Temp ################
	#
	#  Read the 'users' file
	#files
	#if(ok) {
	#	update control {
	#		Auth-Type := Accept
	#	}
	#	updated
	#}
	#####################################
	
	#
	#  If you are using multiple kinds of realms, you probably
	#  want to set "ignore_null = yes" for all of them.
	#  Otherwise, when the first style of realm doesn't match,
	#  the other styles won't be checked.
	#
	######## Temp ########
	#if(!updated) {
	#	suffix
	#}
#	ntdomain



	
	

	#
	#  This module takes care of EAP-MD5, EAP-TLS, and EAP-LEAP
	#  authentication.
	#
	#  It also sets the EAP-Type attribute in the request
	#  attribute list to the EAP type from the packet.
	#
	#  As of 2.0, the EAP module returns "ok" in the authorize stage
	#  for TTLS and PEAP.  In 1.x, it never returned "ok" here, so
	#  this change is compatible with older configurations.
	#
	#  The example below uses module failover to avoid querying all
	#  of the following modules if the EAP module returns "ok".
	#  Therefore, your LDAP and/or SQL servers will not be queried
	#  for the many packets that go back and forth to set up TTLS
	#  or PEAP.  The load on those servers will therefore be reduced.
	

	#################################
	#	Section of EAP-SIM	#
	#################################
	if(EAP-Message){
		#
		#  This unlang is for updating original NAS-IP-Address by Client-IP-Address.
		#  It avoids unreadable NAS-IP-Address in EAP-SIM log because ALU-7750-SR
		#  just proxy EAP Access-Request and keep NAS-IP-Address as IP of AP(Access Point)
		#
		#  Now this function is limited on the condition that *when "%{client:Gateway-Type}" == "ALU"*
		#
		if("%{client:Gateway-Type}" == "ALU"){
			update request{
				NAS-IP-Address := "%{Client-IP-Address}"
			}
		}
		perl_add_roamout_tag
		# if Realm is either "wlan.mnc019.mcc454.3gppnetwork.org" or "wlan.mnc016.mcc454.3gppnetwork.org" (PCCW), change "Packet-Dst-Port" to 9415/9416 
		change_pccw_eapsim_port
		# add empty "Chargeable-User-Identity" to the request list anyway
		if(!Chargeable-User-Identity){
                        cui_authorize
                }

	}
	#################################
	#	Section of UAM		#
	#################################
	else{
		
		# if database is down, use instance "ok" of module "always" to bypass proxy_check
		#set_stripped_uname
		#  
		#  Execute is_multiple_login checking and querying hotspot info
		#  Also doing hotspot auth if Realm is "hotspot"
		#
		if(User-Name !~ /^member\/.+/){
			redundant {
				# use sql_oda
				#proxy_check2
				## use sql-xlat to get value of internal attribute - *Proxy-Check-Str*
				proxy_auth_check
				ok
			}
			## calling perl module to do Authorization & @hotspot Authentication
			perl_proxy_auth_check
		}
		#########################
		#	VIBO AUTH	#
		#########################
		if(User-Name =~ /(.+)\@vibo/){
			perl_vibo_auth
		}
	}
	#################################
	eap {
		ok = return
	}
	
	#  Set WISPr-Location-ID and WISPr-Location-Name as only as either one is null.
	set_wispr_location.authorize	

	#  If you want to have a log of authentication requests,
	#  un-comment the following line, and the 'detail auth_log'
	#  section, above.
	if(FreeRADIUS-WiFi-Realm != "l4.test") {	
		group{
			perl_log {
				fail = 1
				ok = return
			}
			auth_log {
				fail = 1
				ok = return
			}
		}
	}
	#
	#  Pull crypt'd passwords from /etc/passwd or /etc/shadow,
	#  using the system API's to get the password.  If you want
	#  to read /etc/passwd or /etc/shadow directly, see the
	#  passwd module in radiusd.conf.
	#
#	unix
	
	#
	#  Look in an SQL database.  The schema of the database
	#  is meant to mirror the "users" file.
	#
	#  See "Authorization Queries" in sql.conf
	#sql

	#
	#  If you are using /etc/smbpasswd, and are also doing
	#  mschap authentication, the un-comment this line, and
	#  configure the 'etc_smbpasswd' module, above.
#	etc_smbpasswd

	#
	#  The ldap module will set Auth-Type to LDAP if it has not
	#  already been set
#	ldap

	#
	#  Enforce daily limits on time spent logged in.
#	daily

	#
	# Use the checkval module
#	checkval

#	expiration
#	logintime
#
	
	#
	#  If no other module has claimed responsibility for
	#  authentication, then try to use PAP.  This allows the
	#  other modules listed above to add a "known good" password
	#  to the request, and to do nothing else.  The PAP module
	#  will then see that password, and use it to do PAP
	#  authentication.
	#
	#  This module should be listed last, so that the other modules
	#  get a chance to set Auth-Type for themselves.
	#
	pap

	#
	#  If "status_server = yes", then Status-Server messages are passed
	#  through the following section, and ONLY the following section.
	#  This permits you to do DB queries, for example.  If the modules
	#  listed here return "fail", then NO response is sent.
	#
	Autz-Type Status-Server {
		ok
	}
}


#  Authentication.
#
#
#  This section lists which modules are available for authentication.
#  Note that it does NOT mean 'try each module in order'.  It means
#  that a module from the 'authorize' section adds a configuration
#  attribute 'Auth-Type := FOO'.  That authentication type is then
#  used to pick the apropriate module from the list below.
#

#  In general, you SHOULD NOT set the Auth-Type attribute.  The server
#  will figure it out on its own, and will do the right thing.  The
#  most common side effect of erroneously setting the Auth-Type
#  attribute is that one authentication method will work, but the
#  others will not.
#
#  The common reasons to set the Auth-Type attribute by hand
#  is to either forcibly reject the user (Auth-Type := Reject),
#  or to or forcibly accept the user (Auth-Type := Accept).
#
#  Note that Auth-Type := Accept will NOT work with EAP.
#
#  Please do not put "unlang" configurations into the "authenticate"
#  section.  Put them in the "post-auth" section instead.  That's what
#  the post-auth section is for.
#
authenticate {
	#
	#  PAP authentication, when a back-end database listed
	#  in the 'authorize' section supplies a password.  The
	#  password can be clear-text, or encrypted.
	Auth-Type PAP {
		pap
	}

	#
	#  Most people want CHAP authentication
	#  A back-end database listed in the 'authorize' section
	#  MUST supply a CLEAR TEXT password.  Encrypted passwords
	#  won't work.
#	Auth-Type CHAP {
#		chap
#	}

	#
	#  MSCHAP authentication.
#	Auth-Type MS-CHAP {
#		mschap
#	}

	#
	#  If you have a Cisco SIP server authenticating against
	#  FreeRADIUS, uncomment the following line, and the 'digest'
	#  line in the 'authorize' section.
#	digest

	#
	#  Pluggable Authentication Modules.
#	pam

	#
	#  See 'man getpwent' for information on how the 'unix'
	#  module checks the users password.  Note that packets
	#  containing CHAP-Password attributes CANNOT be authenticated
	#  against /etc/passwd!  See the FAQ for details.
	#
	#  For normal "crypt" authentication, the "pap" module should
	#  be used instead of the "unix" module.  The "unix" module should
	#  be used for authentication ONLY for compatibility with legacy
	#  FreeRADIUS configurations.
	#
#	unix

	# Uncomment it if you want to use ldap for authentication
	#
	# Note that this means "check plain-text password against
	# the ldap database", which means that EAP won't work,
	# as it does not supply a plain-text password.
#	Auth-Type LDAP {
#		ldap
#	}

	#
	#  Allow EAP authentication.
	eap

	#
	#  The older configurations sent a number of attributes in
	#  Access-Challenge packets, which wasn't strictly correct.
	#  If you want to filter out these attributes, uncomment
	#  the following lines.
	#
	Auth-Type eap {
		eap {
			handled = 1  
		}
		if (handled && (Response-Packet-Type == Access-Challenge)) {
			attr_filter.access_challenge.post-auth
			handled  # override the "updated" code from attr_filter
		}
	}
}


#
#  Pre-accounting.  Decide which accounting type to use.
#
preacct {
	preprocess

	#
	#  Session start times are *implied* in RADIUS.
	#  The NAS never sends a "start time".  Instead, it sends
	#  a start packet, *possibly* with an Acct-Delay-Time.
	#  The server is supposed to conclude that the start time
	#  was "Acct-Delay-Time" seconds in the past.
	#
	#  The code below creates an explicit start time, which can
	#  then be used in other modules.
	#
	#  The start time is: NOW - delay - session_length
	#

#	  update request {
#	  	FreeRADIUS-Acct-Session-Start-Time = "%{expr: %l - %{%{Acct-Session-Time}:-0} - %{%{Acct-Delay-Time}:-0}}"
#	}


	#
	#  Ensure that we have a semi-unique identifier for every
	#  request, and many NAS boxes are broken.
	#acct_unique

	#
	#  Look for IPASS-style 'realm/', and if not found, look for
	#  '@realm', and decide whether or not to proxy, based on
	#  that.
	#
	#  Accounting requests are generally proxied to the same
	#  home server as authentication requests.
	
	#
	#################
	#project_underline
	#project_realm
	#set_project_realm
	#IPASS
	#suffix

	# Use perl to control realm proxy function
	# 
	# *BUT* STOP proxy meaningless accounting packets generated by coa to home_server
	# All possible *Alc-Subsc-ID-Str* in EAP-SIM Accounting scenarios should be the following format
	#
	# 	MAC|Timestamp 	-> Start 			(O)
	# 	MAC|Timestamp 	-> Stop Admin-Reset 		(O)
	# 	MAC|Timestamp:o -> Start 			(X)
	# 	MAC|Timestamp:o -> Stop Admin-Reset 		(X)
	#
	# The last two scenarios are generated by PM which sends CoA Disconnect to ALU GW, ignore it.
	# So we filter out only case which matches regex of "MAC|Timestamp:o" in *Alc-Subsc-ID-Str* 
	# to not let it go through the proxy-to-realm perl module.
	#
	#if("%{Alc-Subsc-ID-Str}" !~ /([a-fA-F0-9]{2}[:|-]){5}[a-fA-F0-9]{2}\\|([0-9]+):o/){
		perl_set_realm
	#}

	################
	
	# if Realm is either "wlan.mnc019.mcc454.3gppnetwork.org" or "wlan.mnc016.mcc454.3gppnetwork.org" (PCCW), change "Packet-Dst-Port" to 9415/9416 
	#
		change_pccw_eapsim_port	

#	ntdomain

	#
	#  Read the 'acct_users' file
	files
}

#
#  Accounting.  Log the accounting data.
#
accounting {
	#if("%{Alc-Subsc-ID-Str}" =~ /([a-fA-F0-9]{2}[:|-]){5}[a-fA-F0-9]{2}\\|([0-9]+):o/){
	if("%{Alc-SLA-Prof-Str}" == "CHT_SLA_REDIR" && FreeRADIUS-WiFi-Realm =~ /wlan\.mnc[0-9]+.\mcc[0-9]+\.3gppnetwork\.org/){
        	ok = return
		handled
	}
	#if("%{Alc-Subsc-ID-Str}" =~ /([a-fA-F0-9]{2}[:|-]){5}[a-fA-F0-9]{2}\\|([0-9]+)/ && "%{Acct-Terminate-Cause}" == "Admin-Reset"){
	if("%{Alc-SLA-Prof-Str}" == "CHT_SLA" && "%{Acct-Terminate-Cause}" == "Admin-Reset"){
		update request{
			Acct-Terminate-Cause := User-Request
		}
	}
	NAS_Cvrt
	# if we cannot find *FreeRADIUS-WiFi-Realm* set by perl module "perl_set_realm", which means this realm is unknown.
	# Hence, we stop Accounting section by using "handled"
	if(!FreeRADIUS-WiFi-Realm){
		handled
	}

	#########################################
	#	EAP Attributes Editing		#
	#########################################
	add_client_info
	perl_add_roamout_tag
	filter_called_station_id

	#  Formalize Calling-Station-Id 
	rewrite.calling_station_id	

	#  use perl to delete some specific values in *CLASS*
	redundant {
		#  Deleting Class value like these: SBRCL & CUI & duplicate HiNetCL in member/ accouting
		#  adding Chargeable-User-Identity 
		perl_delClass
		#perl_cui_handle
		ok
	}

	#########################################
	#	Statistical Attributes Editing	#
	#########################################
	if("%{Acct-Status-Type}"== "Stop") {
		gen_gigawords
		if("%{Acct-Terminate-Cause}" == Lost-Service){
			update request {
				Acct-Terminate-Cause := Idle-Timeout
			}
		}
		#if("%{Acct-Terminate-Cause}" == Idle-Timeout && "%{client:Gateway-Type}" == "ALU") {
		#   substract Idle-Timeout if this request is from ALU GW
		if("%{Acct-Terminate-Cause}" == Idle-Timeout && "%{Alc-SLA-Prof-Str}" == "CHT_SLA") {
			ito_substract
		}
	}
	
	###############################
        #   Specific unlang for kt/   #
        ###############################
        if(FreeRADIUS-WiFi-Realm == "kt" || FreeRADIUS-WiFi-Realm == "wlan.mnc008.mcc450.3gppnetwork.org"){
                update request{
                        WISPr-Location-ID := "isocc=tw,cc=886,ac=2,network=HiNet"
                }
        }	
	
	#################################
	#	Replicate Accounting	#
	#################################
	# perl module for setting Replicate-To-Realm
	perl_replicate_acct

	# if Realm is belong to PCCW/NTT EAPSIM
	if(FreeRADIUS-WiFi-Realm=="wlan.mnc019.mcc454.3gppnetwork.org"||FreeRADIUS-WiFi-Realm=="wlan.mnc016.mcc454.3gppnetwork.org"||FreeRADIUS-WiFi-Realm == "wlan.mnc010.mcc440.3gppnetwork.org"){
		#  Call stored procedure to get hotsopt info for generating Class:ProxyCL
		redundant{
			# use sql_oda
			get_hotspot_info
			ok
		}
		#  Generating Class: ProxyCL:Venue_ID=Pxxxxxx Hotspot_ID=PHxxxxxx
		gen_Class_acct
	}
	elsif(FreeRADIUS-WiFi-Realm =="wlan.mnc092.mcc466.3gppnetwork.org"){ # if Realm is belong to CHT EAPSIM
		if(Framed-AppleTalk-Zone=="pccw"){
			update control {
				Replicate-To-Realm := hinet.roamout
			}
		}
		else{
			redundant {
				# use sql_oda
				get_hotspot_info
				ok
			}
			gen_Class_acct
		}
	}
	# always replicate accounting to our ACCT server
	if(FreeRADIUS-WiFi-Realm != "l4.test" && FreeRADIUS-WiFi-Realm != "pm.test") {
		update control {
			Replicate-To-Realm += acct_server
		}
		replicate
	}
	#########################
	#	Log Module	#
	#########################
	if(FreeRADIUS-WiFi-Realm != "l4.test") {
		group {
			perl_log {
				fail = 1
				ok = return
			}
			detail {
				fail = 1
				ok = return
			}
		}
		#detail	
	}
#	daily

	#  Update the wtmp file
	#
	#  If you don't use "radlast", you can delete this line.
#	unix

	#
	#  For Simultaneous-Use tracking.
	#
	#  Due to packet losses in the network, the data here
	#  may be incorrect.  There is little we can do about it.
#	radutmp
#	sradutmp

	#  Return an address to the IP Pool when we see a stop record.
#	main_pool

	#
	#  Log traffic to an SQL database.
	#
	#  See "Accounting queries" in sql.conf
#	sql

	#
	#  If you receive stop packets with zero session length,
	#  they will NOT be logged in the database.  The SQL module
	#  will print a message (only in debugging mode), and will
	#  return "noop".
	#
	#  You can ignore these packets by uncommenting the following
	#  three lines.  Otherwise, the server will not respond to the
	#  accounting request, and the NAS will retransmit.
	#
#	if (noop) {
#		ok
#	}

	#
	#  Instead of sending the query to the SQL server,
	#  write it into a log file.
	#
#	sql_log

	#  Cisco VoIP specific bulk accounting
#	pgsql-voip

	# For Exec-Program and Exec-Program-Wait
#	exec

	#  Filter attributes from the accounting response.
	attr_filter.accounting_response

	#
	#  See "Autz-Type Status-Server" for how this works.
	#
	Acct-Type Status-Server {
		ok
	}
}


#  Session database, used for checking Simultaneous-Use. Either the radutmp 
#  or rlm_sql module can handle this.
#  The rlm_sql module is *much* faster
#session {
#	radutmp

	#
	#  See "Simultaneous Use Checking Queries" in sql.conf
#	sql
#}


#  Post-Authentication
#  Once we KNOW that the user has been authenticated, there are
#  additional steps we can take.
post-auth {    
    # if FreeRADIUS-WiFi-Realm is "member" do 'set_realm' and 'proxy_check' in post-auth section
    if(User-Name =~ /^member\/.+/){
    	perl_set_realm
        redundant {
                # use sql_oda
                #proxy_check2
                ## use sql-xlat to get value of internal attribute - *Proxy-Check-Str*
		proxy_auth_check
                ok
        }
        ## calling perl module to do Authorization & @hotspot Authentication
		perl_proxy_auth_check
    }
	update control {
		#Perllog-File-Name := "%{FreeRADIUS-WiFi-Realm}_REPLY"
		Perllog-Result-Type := "PA"
	}
	#}
	#get_realm
	
	if("%{request:EAP-Message}"){
		#  save value of "Chargeable-User-Identity" in Class as format of "CUI=*"
		save_user_identity

		#### if this client is alcatel-lucent, use unlang policy to set qos reply
        #### if gateway is alcatel-lucent, it doesn't allow giving Access-Accept with *Session-Timeout* and *Alc-Relative-Session-Timeout* at the same time.
        if("%{client:Gateway-Type}" == "ALU") {
			if("%{client:Is-NAT}" == "Yes"){
				# update freeradius.internal VSA while we set tag 'Gateway-Type' in Clients.conf as "ALU"
				# the VSA can help us identify if this ALU gateway is NAT mode.
				update control {
					Is-NAT := "Yes"
				}
                ## if this onfig *Is-NAT* of the client is set to 'Yes' that means it turns on NAT mode. Then we apply policy below.
                alu.nat.eapsim.reply
            }

            # perl script for QoS control
        	QoS_Ctrl

            # Calling perl script to check whether the MAC addr of eapsim request have been cached in Redis server.
            # If yes, we will send CoA request to activate the subscriber by Alc-Subsc-ID-Str.
            perl_coa_eapsim
        }
        else{
        	# perl script for QoS control
        	QoS_Ctrl
        }
	}
	else{
		#  use perl to delete SBRCL in *CLASS*
		redundant {
			# Only delete SBRCL
			perl_delClass
			#perl_cui_handle
			ok
		}
		#  Use for generating WISPr-Redirect-URL
		perl_parseCL
                #### The line below is a perl script which belong to Lite-GW for QoS control.
                QoS_Ctrl
		#  unlang policy for generating Class ProxyCL
		gen_Class
	}
	
	#  
	#  LI Check
	#
	redundant {
		LI_Check
		ok
	}

	if(updated){
		update reply{
			Alc-LI-Action := enable
			ALc-LI-Destination := "8888"
		}
	}
	#gen_URL	
	
	#  Set WISPr-Location-ID and WISPr-Location-Name as only as either one is null.
	set_wispr_location.post.auth	

	# NTT-WEST Specific Function
        if("%{client:Reply-Username}" == "Y"){
                update reply {
                        User-Name := "%{request:User-Name}"
                }
        }

	#  Get an address from the IP Pool.
#	main_pool

	#
	#  If you want to have a log of authentication replies,
	#  un-comment the following line, and the 'detail reply_log'
	#  section, above.
	if(FreeRADIUS-WiFi-Realm != "l4.test") {
		group {
			perl_log {
				fail = 1
				ok = return
			}
			reply_log {
				fail =1
				ok = return
			}
		}
	}
	#
	#  After authenticating the user, do another SQL query.
	#
	#  See "Authentication Logging Queries" in sql.conf
#	sql

	#
	#  Instead of sending the query to the SQL server,
	#  write it into a log file.
	#
#	sql_log

	#
	#  Un-comment the following if you have set
	#  'edir_account_policy_check = yes' in the ldap module sub-section of
	#  the 'modules' section.
	#
#	ldap

	# For Exec-Program and Exec-Program-Wait
#	exec

	#
	#  Calculate the various WiMAX keys.  In order for this to work,
	#  you will need to define the WiMAX NAI, usually via
	#
	#	update request {
	#	       WiMAX-MN-NAI = "%{User-Name}"
	#	}
	#
	#  If you want various keys to be calculated, you will need to
	#  update the reply with "template" values.  The module will see
	#  this, and replace the template values with the correct ones
	#  taken from the cryptographic calculations.  e.g.
	#
	# 	update reply {
	#		WiMAX-FA-RK-Key = 0x00
	#		WiMAX-MSK = "%{EAP-MSK}"
	#	}
	#
	#  You may want to delete the MS-MPPE-*-Keys from the reply,
	#  as some WiMAX clients behave badly when those attributes
	#  are included.  See "raddb/modules/wimax", configuration
	#  entry "delete_mppe_keys" for more information.
	#
#	wimax

	#  If there is a client certificate (EAP-TLS, sometimes PEAP
	#  and TTLS), then some attributes are filled out after the
	#  certificate verification has been performed.  These fields
	#  MAY be available during the authentication, or they may be
	#  available only in the "post-auth" section.
	#
	#  The first set of attributes contains information about the
	#  issuing certificate which is being used.  The second
	#  contains information about the client certificate (if
	#  available).
#
#	update reply {
#	       Reply-Message += "%{TLS-Cert-Serial}"
#	       Reply-Message += "%{TLS-Cert-Expiration}"
#	       Reply-Message += "%{TLS-Cert-Subject}"
#	       Reply-Message += "%{TLS-Cert-Issuer}"
#	       Reply-Message += "%{TLS-Cert-Common-Name}"
#	       Reply-Message += "%{TLS-Cert-Subject-Alt-Name-Email}"
#
#	       Reply-Message += "%{TLS-Client-Cert-Serial}"
#	       Reply-Message += "%{TLS-Client-Cert-Expiration}"
#	       Reply-Message += "%{TLS-Client-Cert-Subject}"
#	       Reply-Message += "%{TLS-Client-Cert-Issuer}"
#	       Reply-Message += "%{TLS-Client-Cert-Common-Name}"
#	       Reply-Message += "%{TLS-Client-Cert-Subject-Alt-Name-Email}"
#	}


	#  If the WiMAX module did it's work, you may want to do more
	#  things here, like delete the MS-MPPE-*-Key attributes.
	#
	#	if (updated) {
	#		update reply {
	#			MS-MPPE-Recv-Key !* 0x00
	#			MS-MPPE-Send-Key !* 0x00
	#		}
	#	}

	#
	#  Access-Reject packets are sent through the REJECT sub-section of the
	#  post-auth section.
	#
	#  Add the ldap module name (or instance) if you have set 
	#  'edir_account_policy_check = yes' in the ldap module configuration
	#
	Post-Auth-Type REJECT {
		# log failed authentications in SQL, too.
#		sql
		#if("%{control:Tmp-Roaming-Tag}" == "international") {
		if("%{Realm}" !~ /[a-zA-Z0-9]*\.?hinet\.net$/ && "%{Realm}" != "member") {
			reject.reply_message
                	if(!"%{reply:Reply-Message}"){
				override_replyMsg_on_reject
			}
		}
		if(!"%{control:Perllog-Result-Type}"){
			update control {
                        	Perllog-Result-Type := "PJ"
                	}
		}
		if(FreeRADIUS-WiFi-Realm != "l4.test") {
                	perl_log
		}
		attr_filter.access_reject
		#reject_log
	}
}

#
#  When the server decides to proxy a request to a home server,
#  the proxied request is first passed through the pre-proxy
#  stage.  This stage can re-write the request, or decide to
#  cancel the proxy.
#
#  Only a few modules currently have this method.
#
pre-proxy {
#	attr_rewrite

	#  Uncomment the following line if you want to change attributes
	#  as defined in the preproxy_users file.
#	files

	# Editing User-Name of proxy-request while FreeRADIUS-WiFi-Realm = member & Proxy-To-Realm = emome.net
        if("%{request:FreeRADIUS-WiFi-Realm}" == "member" && "%{control:Proxy-To-Realm}" == "emome.net") {
                update proxy-request {
                        User-Name := "%{control:Tmp-String-1}"
                }
        }
	
	#  If you want to have a log of packets proxied to a home
	#  server, un-comment the following line, and the
	#  'detail pre_proxy_log' section, above.
        if(Packet-Type == "Access-Request") {
		update control {
			Packet-Type := "Access-Request"
		}
		perl_log
        #	auth_pre_proxy_log
        }
	#  Uncomment the following line if you want to filter requests
	#  sent to remote servers based on the rules defined in the
	#  'attrs.pre-proxy' file.
	attr_filter.pre-proxy

        #elsif("%{control:Packet-type}" == "Accounting-Request") {
        #        acct_pre_proxy_log
        #}
        #else{
        #}

}

#
#  When the server receives a reply to a request it proxied
#  to a home server, the request may be massaged here, in the
#  post-proxy stage.
#
post-proxy {
	#  If you want to have a log of replies from a home server,
	#  un-comment the following line, and the 'detail post_proxy_log'
	#  section, above.
	#if("%{Packet-Type}" == "Access-Accept" || "%{control:Response-Packet-Type}" == "Access-Reject") {
        #        auth_post_proxy_log
        #}
        #elsif("%{Packet-Type}" == "Accounting-Response") {
        #        acct_post_proxy_log
        #}
        #else{
	#	post_proxy_log	
        #}
	perl_log
        #       auth_pre_proxy_log
        
#	attr_rewrite
	#  Uncomment the following line if you want to filter replies from
	#  remote proxies based on the rules defined in the 'attrs' file.
#	attr_filter.post-proxy

	#
	#  If you are proxying LEAP, you MUST configure the EAP
	#  module, and you MUST list it here, in the post-proxy
	#  stage.
	#
	#  You MUST also use the 'nostrip' option in the 'realm'
	#  configuration.  Otherwise, the User-Name attribute
	#  in the proxied request will not match the user name
	#  hidden inside of the EAP packet, and the end server will
	#  reject the EAP request.
	#
#	eap

	#
	#  If the server tries to proxy a request and fails, then the
	#  request is processed through the modules in this section.
	#
	#  The main use of this section is to permit robust proxying
	#  of accounting packets.  The server can be configured to
	#  proxy accounting packets as part of normal processing.
	#  Then, if the home server goes down, accounting packets can
	#  be logged to a local "detail" file, for processing with
	#  radrelay.  When the home server comes back up, radrelay
	#  will read the detail file, and send the packets to the
	#  home server.
	#
	#  With this configuration, the server always responds to
	#  Accounting-Requests from the NAS, but only writes
	#  accounting packets to disk if the home server is down.
	#
	Post-Proxy-Type Fail {
		if(Packet-Type == "Access-Request") {
			update control {
				Packet-Type := "Access-Request"
				Perllog-Result-Type := "PJ(TO)"
			}
		}
        	perl_log
		#if(Packet-Type == "Accounting-Request") {
		#	detail.acct.fail
		#}
	}
}

